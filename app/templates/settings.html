{% extends "base.html" %}

{% block title %}Settings{% endblock %}

{% block styles %}
  <style>
    .container {
      text-align: left;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      padding: 20px;
    }
    .indent {
      margin-left: 20px;
    }
  </style>
{% endblock %}

{% block content %}
  <form method="post" action="/settings">
    <h1>Settings</h1>

    Click "Save" to apply your changes. Login with Google to save your settings and progress across sessions.

    <br><br>

    {% if "@" in user_id %}
      <!-- Show stats table and scatter plot -->
       <h3 style="margin-bottom: 0.5em;">{{ user_id }}</h3>

      <section style="margin-bottom: 2em;">
        <table style="border-collapse: separate; border-spacing: 0em 0.5em; margin-top: 1em; margin-bottom: 1em; margin-left: 1em;">
          <tr>
            <td style="padding-right: 1.5em;"><strong>Timestamp:</strong></td>
            <td id="last-reviewed-time">{{ stats.date_time or '' }}</td>
          </tr>
          <tr>
            <td style="padding-right: 1.5em;"><strong>Verses Reviewed:</strong></td><td>{{ stats.verses_reviewed | int }}</td>
          </tr>
          <tr>
            <td style="padding-right: 1.5em;"><strong>Total Score:</strong></td><td>{{ stats.total_score | int }}</td>
          </tr>
          <tr>
            <td style="padding-right: 1.5em;"><strong>Total Points:</strong></td><td>{{ stats.total_points | int }}</td>
          </tr>
          <tr>
            <td style="padding-right: 1.5em;"><strong>Past 30 Days:</strong></td><td>{{ stats.points_30days | int }}</td>
          </tr>
        </table>
      </section>

      {% if review_data %}
        <h3 style="margin-bottom: 0.5em;">Review Progress</h3>
        <div id="review-scatter" style="height: 400px;"></div>

        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <script>
          const reviewData = {{ review_data | tojson }};
          
          const log10Weights = reviewData.map(r => r.log10_weight);
          const retrievabilities = reviewData.map(r => r.retrievability);
          const sizes = log10Weights.map(w => Math.min(w * 10, 100));

          const minRet = Math.min(...retrievabilities);
          const maxRet = Math.max(...retrievabilities);
          const midRet = (minRet + maxRet) / 2;

          const formattedDueDates = reviewData.map(r => {
            try {
              const date = new Date(r.due);
              const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'America/Los_Angeles';
              const localDate = new Date(date.toLocaleString('en-US', { timeZone: tz }));

              const pad = n => n.toString().padStart(2, '0');
              const yyyy = localDate.getFullYear();
              const mm = pad(localDate.getMonth() + 1);
              const dd = pad(localDate.getDate());
              const hh = pad(localDate.getHours());
              const min = pad(localDate.getMinutes());
              const ss = pad(localDate.getSeconds());

              return `${yyyy}-${mm}-${dd} ${hh}:${min}:${ss}`;
            } catch {
              return 'Invalid date';
            }
          });

          let markerOptions;

          if (minRet === maxRet) {
            // Fixed color scale fallback
            function getColorFromRetrievability(ret) {
              if (ret <= 0.5) {
                // interpolate red to yellow
                const t = ret / 0.5;
                return `rgb(${Math.round(220 + (255 - 220) * t)}, ${Math.round(20 + (215 - 20) * t)}, 60)`;
              } else {
                // interpolate yellow to green
                const t = (ret - 0.5) / 0.5;
                return `rgb(${Math.round(255 - (221 * t))}, ${Math.round(215 - (215 - 139) * t)}, 0)`;
              }
            }

            const fixedColor = getColorFromRetrievability(minRet);
            markerOptions = {
              color: fixedColor,
              size: sizes,
              sizemode: 'diameter',
              sizemin: 5,
              opacity: 0.8
            };
          } else {
            markerOptions = {
              color: retrievabilities,
              colorscale: [
                [0, 'rgb(220, 20, 60)'],
                [(midRet - minRet) / (maxRet - minRet), 'rgb(255, 215, 0)'],
                [1, 'rgb(34, 139, 34)']
              ],
              cmin: minRet,
              cmax: maxRet,
              colorbar: { title: 'Retrievability' },
              size: sizes,
              sizemode: 'diameter',
              sizemin: 5,
              opacity: 0.8
            };
          }

          const trace = {
            x: reviewData.map(r => r.time),
            y: reviewData.map(r => r.distance),
            text: reviewData.map(r => r.verse),
            mode: 'markers',
            type: 'scatter',
            marker: markerOptions,
            customdata: reviewData.map((r, i) => [log10Weights[i], formattedDueDates[i], r.due_in, r.url]),
            hovertemplate:
              "<b>%{text}</b><br>" +
              "Time: %{x}s<br>" +
              "Distance: %{y}<br>" +
              // "Due: %{customdata[1]}<br>" +
              "Due: %{customdata[2]}<br>" +
              (minRet === maxRet
                ? `Retrievability: ${minRet.toFixed(2)}<br>`
                : "Retrievability: %{marker.color:.2f}<br>") +
              "<extra></extra>"
          };

          Plotly.newPlot('review-scatter', [trace], {
            margin: { t: 10 },
            xaxis: { title: 'Seconds' },
            yaxis: { title: 'Distance' },
            responsive: true,
          });
          document.getElementById('review-scatter').on('plotly_click', function(data) {
            const url = data.points[0].customdata[3];
            if (url) {
              window.open(url, '_blank');
            }
          });
        </script>
      {% endif %}
    {% endif %}

    <h3>Review Settings</h3>

    <label for="translation">Bible Translation:</label>
    <select name="translation" id="translation">
      {% for trans in avail_translations %}
        <option value="{{ trans }}"
          {% if trans == selected_translation %}selected{% endif %}>
          {{ trans | upper }}
        </option>
      {% endfor %}
    </select>

    <br><br>

    <label for="priority">Verse Priority:</label>
    <select name="priority" id="priority">
      <option value="uniform" {% if priority == "uniform" %}selected{% endif %}>Uniform</option>
      <option value="weighted" {% if priority == "weighted" %}selected{% endif %}>Weighted</option>
    </select>

    <br><br>
    
    <label for="selector">Selection Method:</label>
    <select name="selector" id="selector">
      <option value="random" {% if selector == "random" %}selected{% endif %}>Random</option>
      <option value="greedy" {% if selector == "greedy" %}selected{% endif %}>Greedy</option>
    </select>

    <p id="method-description" style="font-style: italic; margin-top: 1.5em; margin-bottom: 2em;"></p>

    <h3>Review Selection</h3>

    <ul>
      <li>Select testaments, books, and/or chapters to review. If none are selected, defaults to the whole Bible.</li>
      <li>If a testament is selected, all of its books are included. Similarly, if a book is selected, all of its chapters are included. Otherwise, only selected chapters are included.</li>
    </ul>
    <br>

    <label>
      <input type="checkbox" name="selected_testaments" value="old"
        {% if "old" in selected_testaments %}checked{% endif %}>
      <strong>Old Testament</strong><br><br>
    </label>
    <div class="indent">
      {% for book in ot_books %}
        <label>
          <input type="checkbox" name="selected_books" value="{{ book }}"
            {% if book in selected_books %}checked{% endif %}>
          {{ book }}
        </label>
        {% if book in chapter_counts and chapter_counts[book] > 1 %}
          <div class="indent">
            {% for chapter in range(1, chapter_counts[book] + 1) %}
              <label>
                <input type="checkbox" name="selected_chapters"
                       value="{{ book }}|{{ chapter }}"
                       {% if book in selected_chapters and chapter in selected_chapters[book] %}checked{% endif %}>
                {{ chapter }}
              </label>
            {% endfor %}
          </div>
        {% else %}
          <br>
        {% endif %}
        <br>
      {% endfor %}
    </div>

    <br>
    <label>
      <input type="checkbox" name="selected_testaments" value="new"
        {% if "new" in selected_testaments %}checked{% endif %}>
      <strong>New Testament</strong><br><br>
    </label>
    <div class="indent">
      {% for book in nt_books %}
        <label>
          <input type="checkbox" name="selected_books" value="{{ book }}"
            {% if book in selected_books %}checked{% endif %}>
          {{ book }}
        </label>
        {% if book in chapter_counts and chapter_counts[book] > 1 %}
          <div class="indent">
            {% for chapter in range(1, chapter_counts[book] + 1) %}
              <label>
                <input type="checkbox" name="selected_chapters"
                       value="{{ book }}|{{ chapter }}"
                       {% if book in selected_chapters and chapter in selected_chapters[book] %}checked{% endif %}>
                {{ chapter }}
              </label>
            {% endfor %}
          </div>
        {% else %}
          <br>
        {% endif %}
        <br>
      {% endfor %}
    </div>

    <br>
    <button type="submit" style="font-size: 1em;">Save</button>
  </form>

  <script>
  document.addEventListener("DOMContentLoaded", function () {
    const elem = document.getElementById("last-reviewed-time");
    if (!elem || !elem.textContent) return;

    try {
      const iso = elem.textContent.trim();
      const dt = new Date(iso);
      
      // Try local timezone first
      let options = {
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      };
      
      // Format as YYYY-MM-DD HH:mm:ss
      const parts = new Intl.DateTimeFormat(undefined, options).formatToParts(dt);
      const date = `${parts.find(p => p.type === 'year').value}-${parts.find(p => p.type === 'month').value}-${parts.find(p => p.type === 'day').value}`;
      const time = `${parts.find(p => p.type === 'hour').value}:${parts.find(p => p.type === 'minute').value}:${parts.find(p => p.type === 'second').value}`;
      
      elem.textContent = `${date} ${time}`;
    } catch (e) {
      // If error or unknown timezone, fallback to Pacific Time
      try {
        const dt = new Date(elem.textContent.trim());
        const pacificTime = new Date(dt.toLocaleString("en-US", { timeZone: "America/Los_Angeles" }));
        elem.textContent = pacificTime.toISOString().slice(0, 19).replace("T", " ");
      } catch {
        // Fallback silently if formatting fails
      }
    }
  });
  </script>

  <script>
    const translationSelect = document.getElementById("translation");
    const prioritySelect = document.getElementById("priority");
    const selectorSelect = document.getElementById("selector");
    const description = document.getElementById("method-description");

    function updateDescription() {
      const translation = translationSelect.value.toUpperCase();
      const priority = prioritySelect.value;
      const selector = selectorSelect.value;

      let desc = `Using text from the ${translation} translation. `;

      if (selector === "random") {
        desc += "Randomly select verses from review selection with probability proportional to weight, ";
      } else if (selector === "greedy") {
        desc += "Select verses from review selection with the highest weight, ";
      }

      if (priority === "weighted") {
        desc += `with greater initial weight given to more commonly cited verses in <a href=https://www.gty.org/>gty.org</a> sermons and <a href=https://www.desiringgod.org/>desiringgod.org</a> resources. `;
      } else {
        desc += "with equal initial weight given to all verses. ";
      }

      desc += "Verse weights are scaled down when recently reviewed and inflated when past due."

      description.innerHTML = desc;
    }

    // Initialize and bind listeners
    translationSelect.addEventListener("change", updateDescription);
    prioritySelect.addEventListener("change", updateDescription);
    selectorSelect.addEventListener("change", updateDescription);

    // Call once on page load
    updateDescription();
  </script>
{% endblock %}
